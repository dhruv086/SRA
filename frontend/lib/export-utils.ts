import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import JSZip from 'jszip';
import { saveAs } from 'file-saver';

import type { AnalysisResult } from '@/types/analysis';
import mermaid from 'mermaid';

mermaid.initialize({
    startOnLoad: false,
    theme: 'base',
    securityLevel: 'loose',
});



// Helper: Convert SVG string to PNG Blob
const svgToPng = (svgStr: string): Promise<Blob | null> => {
    return new Promise((resolve) => {
        // Parse SVG to get dimensions from viewBox
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgStr, "image/svg+xml");
        const svgElement = doc.documentElement;

        let width = 0;
        let height = 0;

        const viewBox = svgElement.getAttribute('viewBox');
        if (viewBox) {
            const parts = viewBox.split(/\s+/).map(parseFloat);
            if (parts.length === 4) {
                width = parts[2];
                height = parts[3];
            }
        }

        // Fallback or override width/height attributes to match viewBox (crucial for correct rendering in Image)
        if (width && height) {
            svgElement.setAttribute('width', `${width}px`);
            svgElement.setAttribute('height', `${height}px`);
        } else {
            // Try to get headers if viewBox missing
            width = parseFloat(svgElement.getAttribute('width') || '0');
            height = parseFloat(svgElement.getAttribute('height') || '0');
        }

        // Serialize back to string
        const serializer = new XMLSerializer();
        const finalSvgStr = serializer.serializeToString(svgElement);

        const img = new Image();
        img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(finalSvgStr);

        img.onload = () => {
            const canvas = document.createElement('canvas');
            // Scale up for better resolution
            const scale = 3;

            // Use intrinsic parsed dimensions if available, else natural
            const finalWidth = width || img.width || 800;
            const finalHeight = height || img.height || 600;

            canvas.width = finalWidth * scale;
            canvas.height = finalHeight * scale;

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                resolve(null);
                return;
            }

            // Fill white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.scale(scale, scale);
            ctx.drawImage(img, 0, 0, finalWidth, finalHeight);

            canvas.toBlob((blob) => {
                resolve(blob);
            }, 'image/png', 1.0);
        };

        img.onerror = (e) => {
            console.error("SVG to PNG conversion failed", e);
            resolve(null);
        };
    });
};

export const generateSRS = (data: AnalysisResult, title: string) => {
    const doc = new jsPDF();
    let yPos = 20;

    // Title Page
    doc.setFontSize(24);
    doc.text(title || "Software Requirements Specification", 20, 100);
    doc.setFontSize(14);
    doc.text(`Generated by SRAnalyzer`, 20, 110);
    doc.text(new Date().toLocaleDateString(), 20, 120);
    doc.addPage();

    // 1. Overview
    if (data.cleanedRequirements) {
        doc.setFontSize(18);
        doc.text("1. Overview", 14, yPos);
        yPos += 10;
        doc.setFontSize(12);
        try {
            const splitText = doc.splitTextToSize(data.cleanedRequirements, 180);
            doc.text(splitText, 14, yPos);
            yPos += (splitText.length * 7) + 10;
        } catch (e) {
            console.error("Error adding overview text", e);
        }
    }

    // 2. Functional Requirements
    if (data.functionalRequirements?.length) {
        doc.setFontSize(18);
        doc.text("2. Functional Requirements", 14, yPos);
        yPos += 10;
        const frRows = data.functionalRequirements.map((req, i) => [`FR-${i + 1}`, req]);
        try {
            autoTable(doc, {
                startY: yPos,
                head: [['ID', 'Requirement']],
                body: frRows,
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            yPos = (doc as any).lastAutoTable.finalY + 15;
        } catch (_e) {
            console.error("Error adding FR table", _e);
            yPos += 20;
        }
    }

    // 3. User Stories
    if (data.userStories?.length) {
        doc.setFontSize(18);
        doc.text("3. User Stories", 14, yPos);
        yPos += 10;
        const usRows = data.userStories.map((us) => [us.role, us.feature, us.story]);
        try {
            autoTable(doc, {
                startY: yPos,
                head: [['Role', 'Feature', 'Story']],
                body: usRows,
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            yPos = (doc as any).lastAutoTable.finalY + 15;
        } catch (_e) {
            console.error("Error adding US table", _e);
            yPos += 20;
        }
    }

    return doc;
};

export const generateAPI = (data: AnalysisResult) => {
    let content = "# API Documentation\n\n";
    if (data.apiContracts?.length) {
        data.apiContracts.forEach(api => {
            content += `## ${api.method} ${api.endpoint}\n`;
            content += `${api.description || ''}\n\n`;
            try {
                content += "### Request Body\n```json\n" + JSON.stringify(api.requestBody || {}, null, 2) + "\n```\n\n";
                content += "### Response Body\n```json\n" + JSON.stringify(api.responseBody || {}, null, 2) + "\n```\n\n";
            } catch {
                content += "Error parsing body JSON\n\n";
            }
            content += "---\n\n";
        });
    }
    return content;
};

export const downloadBundle = async (data: AnalysisResult, title: string) => {
    const zip = new JSZip();

    try {
        // 1. SRS PDF
        const srsDoc = generateSRS(data, title);
        zip.file("SRS_Report.pdf", srsDoc.output('blob'));
    } catch (e) {
        console.error("Failed to add SRS to bundle", e);
    }

    // 2. API Markdown
    try {
        const apiMd = generateAPI(data);
        zip.file("API_Blueprint.md", apiMd);
    } catch (e) {
        console.error("Failed to add API to bundle", e);
    }

    // 3. raw JSON
    try {
        zip.file("analysis.json", JSON.stringify(data, null, 2));
    } catch { }

    // 4. Diagrams (SVG & MMD)
    // Helper to render
    const renderDiagram = async (code: string, id: string) => {
        try {
            if (!code) return null;
            // Unique ID to avoid conflicts
            const uniqueId = `${id}-${Math.random().toString(36).substr(2, 9)}`;
            const { svg } = await mermaid.render(uniqueId, code);
            return svg;
        } catch (e) {
            console.error(`Failed to render diagram ${id}`, e);
            return null;
        }
    };

    if (data.flowchartDiagram) {
        try {
            zip.file("diagrams/flowchart.mmd", data.flowchartDiagram);
            const svg = await renderDiagram(data.flowchartDiagram, 'export-flowchart');
            if (svg) {
                zip.file("diagrams/flowchart.svg", svg);
                const png = await svgToPng(svg);
                if (png) zip.file("diagrams/flowchart.png", png);
            }
        } catch (e) {
            console.warn("Failed to process flowchart for bundle", e);
        }
    }

    if (data.sequenceDiagram) {
        try {
            zip.file("diagrams/sequence.mmd", data.sequenceDiagram);
            const svg = await renderDiagram(data.sequenceDiagram, 'export-sequence');
            if (svg) {
                zip.file("diagrams/sequence.svg", svg);
                const png = await svgToPng(svg);
                if (png) zip.file("diagrams/sequence.png", png);
            }
        } catch (e) {
            console.warn("Failed to process sequence diagram for bundle", e);
        }
    }

    const content = await zip.generateAsync({ type: "blob" });
    saveAs(content, `${title.replace(/\s+/g, '_')}_Bundle.zip`);
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const downloadCodebase = async (codeData: any, title: string) => {
    const zip = new JSZip();

    // 1. Schema
    if (codeData.databaseSchema) {
        zip.file("prisma/schema.prisma", codeData.databaseSchema);
    }

    // 2. Add Code Files
    const addFiles = (files: { path: string, code: string }[]) => {
        files.forEach(f => {
            // Remove leading slash if present
            const cleanPath = f.path.startsWith('/') ? f.path.slice(1) : f.path;
            zip.file(cleanPath, f.code);
        });
    }

    if (codeData.backendRoutes) addFiles(codeData.backendRoutes);
    if (codeData.frontendComponents) addFiles(codeData.frontendComponents);
    if (codeData.testCases) addFiles(codeData.testCases);

    // 3. Add READMEs
    if (codeData.backendReadme) {
        zip.file("backend/README.md", codeData.backendReadme);
    }
    if (codeData.frontendReadme) {
        zip.file("frontend/README.md", codeData.frontendReadme);
    }

    // 3. Create skeleton from fileStructure if needed (optional, skipping for now to rely on explicit code)

    const content = await zip.generateAsync({ type: "blob" });
    saveAs(content, `${title.replace(/\s+/g, '_')}_Codebase.zip`);
};
